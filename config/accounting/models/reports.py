"""
Report models for financial reporting.

This module contains models for managing financial reports,
report templates, and scheduled report generation.
"""

from django.db import models
from django.core.validators import MinValueValidator
from django.core.exceptions import ValidationError
from django.utils import timezone
import uuid
import json

from core.models import TimeStampedModel, SoftDeleteModel


class ReportTemplate(models.Model):
    """
    Model for defining report templates.
    
    Report templates define the structure and format of financial reports
    that can be generated by the system.
    """
    BALANCE_SHEET = 'BALANCE_SHEET'
    INCOME_STATEMENT = 'INCOME_STATEMENT'
    CASH_FLOW = 'CASH_FLOW'
    TRIAL_BALANCE = 'TRIAL_BALANCE'
    GENERAL_LEDGER = 'GENERAL_LEDGER'
    ACCOUNT_RECONCILIATION = 'ACCOUNT_RECONCILIATION'
    CUSTOM = 'CUSTOM'
    
    REPORT_TYPE_CHOICES = [
        (BALANCE_SHEET, 'Balance Sheet'),
        (INCOME_STATEMENT, 'Income Statement'),
        (CASH_FLOW, 'Cash Flow Statement'),
        (TRIAL_BALANCE, 'Trial Balance'),
        (GENERAL_LEDGER, 'General Ledger'),
        (ACCOUNT_RECONCILIATION, 'Account Reconciliation'),
        (CUSTOM, 'Custom Report'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=200, verbose_name="Template Name")
    report_type = models.CharField(max_length=50, choices=REPORT_TYPE_CHOICES, verbose_name="Report Type")
    description = models.TextField(blank=True, verbose_name="Description")
    
    # Template configuration
    template_config = models.JSONField(default=dict, verbose_name="Template Configuration")
    parameters = models.JSONField(default=list, verbose_name="Report Parameters")
    filters = models.JSONField(default=list, verbose_name="Report Filters")
    
    # Display settings
    is_active = models.BooleanField(default=True, verbose_name="Is Active")
    sort_order = models.PositiveIntegerField(default=0, verbose_name="Sort Order")
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True, verbose_name="Created At")
    updated_at = models.DateTimeField(auto_now=True, verbose_name="Updated At")
    
    class Meta:
        verbose_name = "Report Template"
        verbose_name_plural = "Report Templates"
        ordering = ['report_type', 'sort_order', 'name']
    
    def __str__(self):
        return f"{self.get_report_type_display()} - {self.name}"
    
    def get_parameter_names(self):
        """Get list of parameter names for this template."""
        return [param.get('name', '') for param in self.parameters]
    
    def get_filter_names(self):
        """Get list of filter names for this template."""
        return [filter_config.get('name', '') for filter_config in self.filters]


class Report(TimeStampedModel, SoftDeleteModel):
    """
    Model for generated financial reports.
    
    This model stores the results of generated reports, including
    the data, parameters used, and metadata about the generation.
    """
    PENDING = 'PENDING'
    GENERATING = 'GENERATING'
    COMPLETED = 'COMPLETED'
    FAILED = 'FAILED'
    CANCELLED = 'CANCELLED'
    
    STATUS_CHOICES = [
        (PENDING, 'Pending'),
        (GENERATING, 'Generating'),
        (COMPLETED, 'Completed'),
        (FAILED, 'Failed'),
        (CANCELLED, 'Cancelled'),
    ]
    
    PDF = 'PDF'
    EXCEL = 'EXCEL'
    CSV = 'CSV'
    JSON = 'JSON'
    HTML = 'HTML'
    
    FORMAT_CHOICES = [
        (PDF, 'PDF'),
        (EXCEL, 'Excel'),
        (CSV, 'CSV'),
        (JSON, 'JSON'),
        (HTML, 'HTML'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    report_number = models.CharField(max_length=50, unique=True, verbose_name="Report Number")
    name = models.CharField(max_length=200, verbose_name="Report Name")
    description = models.TextField(blank=True, verbose_name="Description")
    
    # Report configuration
    template = models.ForeignKey(ReportTemplate, on_delete=models.PROTECT, related_name='reports', verbose_name="Report Template")
    parameters = models.JSONField(default=dict, verbose_name="Report Parameters")
    filters = models.JSONField(default=dict, verbose_name="Report Filters")
    
    # Generation details
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default=PENDING, verbose_name="Status")
    format = models.CharField(max_length=10, choices=FORMAT_CHOICES, default=PDF, verbose_name="Output Format")
    generated_by = models.ForeignKey('auth.User', on_delete=models.SET_NULL, null=True, blank=True, related_name='generated_reports', verbose_name="Generated By")
    
    # Data and files
    report_data = models.JSONField(default=dict, verbose_name="Report Data")
    file_path = models.CharField(max_length=500, blank=True, verbose_name="File Path")
    file_size = models.PositiveIntegerField(default=0, verbose_name="File Size (bytes)")
    
    # Timing
    generation_started = models.DateTimeField(null=True, blank=True, verbose_name="Generation Started")
    generation_completed = models.DateTimeField(null=True, blank=True, verbose_name="Generation Completed")
    error_message = models.TextField(blank=True, verbose_name="Error Message")
    
    class Meta:
        verbose_name = "Report"
        verbose_name_plural = "Reports"
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['report_number']),
            models.Index(fields=['status']),
            models.Index(fields=['template', 'status']),
            models.Index(fields=['generated_by']),
        ]
    
    def __str__(self):
        return f"{self.report_number} - {self.name}"
    
    def save(self, *args, **kwargs):
        """Override save to auto-generate report number if not provided."""
        if not self.report_number:
            self.report_number = self.generate_report_number()
        super().save(*args, **kwargs)
    
    def generate_report_number(self):
        """Generate a unique report number."""
        import datetime
        prefix = f"RPT{datetime.datetime.now().strftime('%Y%m%d')}"
        last_report = Report.objects.filter(
            report_number__startswith=prefix
        ).order_by('-report_number').first()
        
        if last_report:
            last_number = int(last_report.report_number[-4:])
            new_number = last_number + 1
        else:
            new_number = 1
        
        return f"{prefix}{new_number:04d}"
    
    def start_generation(self, user):
        """Start the report generation process."""
        self.status = self.GENERATING
        self.generated_by = user
        self.generation_started = timezone.now()
        self.save()
    
    def complete_generation(self, data, file_path=None, file_size=0):
        """Mark the report as completed with data."""
        self.status = self.COMPLETED
        self.report_data = data
        self.file_path = file_path or ''
        self.file_size = file_size
        self.generation_completed = timezone.now()
        self.save()
    
    def fail_generation(self, error_message):
        """Mark the report generation as failed."""
        self.status = self.FAILED
        self.error_message = error_message
        self.generation_completed = timezone.now()
        self.save()
    
    def cancel_generation(self):
        """Cancel the report generation."""
        self.status = self.CANCELLED
        self.generation_completed = timezone.now()
        self.save()
    
    def get_generation_time(self):
        """Get the time taken to generate the report."""
        if self.generation_started and self.generation_completed:
            return self.generation_completed - self.generation_started
        return None
    
    def get_file_url(self):
        """Get the URL for downloading the report file."""
        if self.file_path:
            return f"/media/reports/{self.file_path}"
        return None
    
    def is_downloadable(self):
        """Check if the report file is available for download."""
        return self.status == self.COMPLETED and self.file_path


class ReportSchedule(TimeStampedModel):
    """
    Model for scheduling automatic report generation.
    
    This model allows users to schedule reports to be generated
    automatically at specified intervals.
    """
    DAILY = 'DAILY'
    WEEKLY = 'WEEKLY'
    MONTHLY = 'MONTHLY'
    QUARTERLY = 'QUARTERLY'
    YEARLY = 'YEARLY'
    CUSTOM = 'CUSTOM'
    
    FREQUENCY_CHOICES = [
        (DAILY, 'Daily'),
        (WEEKLY, 'Weekly'),
        (MONTHLY, 'Monthly'),
        (QUARTERLY, 'Quarterly'),
        (YEARLY, 'Yearly'),
        (CUSTOM, 'Custom'),
    ]
    
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=200, verbose_name="Schedule Name")
    description = models.TextField(blank=True, verbose_name="Description")
    
    # Schedule configuration
    template = models.ForeignKey(ReportTemplate, on_delete=models.CASCADE, related_name='schedules', verbose_name="Report Template")
    frequency = models.CharField(max_length=20, choices=FREQUENCY_CHOICES, verbose_name="Frequency")
    parameters = models.JSONField(default=dict, verbose_name="Report Parameters")
    filters = models.JSONField(default=dict, verbose_name="Report Filters")
    format = models.CharField(max_length=10, choices=Report.FORMAT_CHOICES, default=Report.PDF, verbose_name="Output Format")
    
    # Schedule timing
    start_date = models.DateField(verbose_name="Start Date")
    end_date = models.DateField(null=True, blank=True, verbose_name="End Date")
    next_run = models.DateTimeField(null=True, blank=True, verbose_name="Next Run")
    
    # Recipients
    recipients = models.JSONField(default=list, verbose_name="Recipients")
    email_subject = models.CharField(max_length=200, blank=True, verbose_name="Email Subject")
    email_message = models.TextField(blank=True, verbose_name="Email Message")
    
    # Status
    is_active = models.BooleanField(default=True, verbose_name="Is Active")
    created_by = models.ForeignKey('auth.User', on_delete=models.CASCADE, related_name='created_schedules', verbose_name="Created By")
    
    class Meta:
        verbose_name = "Report Schedule"
        verbose_name_plural = "Report Schedules"
        ordering = ['-created_at']
    
    def __str__(self):
        return f"{self.name} - {self.get_frequency_display()}"
    
    def clean(self):
        """Validate schedule data."""
        if self.start_date and self.end_date:
            if self.start_date > self.end_date:
                raise ValidationError("Start date cannot be after end date.")
        
        if self.start_date and self.start_date < timezone.now().date():
            raise ValidationError("Start date cannot be in the past.")
    
    def calculate_next_run(self):
        """Calculate the next run date based on frequency."""
        if not self.is_active:
            return None
        
        from datetime import timedelta
        from dateutil.relativedelta import relativedelta
        
        if self.next_run is None:
            next_run = timezone.now()
        else:
            next_run = self.next_run
        
        if self.frequency == self.DAILY:
            next_run += timedelta(days=1)
        elif self.frequency == self.WEEKLY:
            next_run += timedelta(weeks=1)
        elif self.frequency == self.MONTHLY:
            next_run += relativedelta(months=1)
        elif self.frequency == self.QUARTERLY:
            next_run += relativedelta(months=3)
        elif self.frequency == self.YEARLY:
            next_run += relativedelta(years=1)
        else:  # CUSTOM
            # Custom frequency would need custom logic
            next_run += timedelta(days=1)
        
        return next_run
    
    def should_run(self):
        """Check if the schedule should run now."""
        if not self.is_active:
            return False
        
        if self.next_run is None:
            return False
        
        if self.end_date and timezone.now().date() > self.end_date:
            return False
        
        return timezone.now() >= self.next_run
    
    def get_recipient_emails(self):
        """Get list of recipient email addresses."""
        return [recipient.get('email', '') for recipient in self.recipients if recipient.get('email')]
    
    def get_recipient_names(self):
        """Get list of recipient names."""
        return [recipient.get('name', '') for recipient in self.recipients if recipient.get('name')] 